<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello Hexo</title>
    <url>/2020/09/05/Hello-Hexo/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
  </entry>
  <entry>
    <title>初识结构模板：pair类型简谈</title>
    <url>/2020/09/05/%E5%88%9D%E8%AF%86%E7%BB%93%E6%9E%84%E6%A8%A1%E6%9D%BF%EF%BC%9Apair%E7%B1%BB%E5%9E%8B%E7%AE%80%E8%B0%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天补网课的时候看到<a href="https://www.luogu.com.cn/problem/P1443">P1443 马的遍历</a>这道题，</p>
<p>属于BFS的一种简单应用，</p>
<p>但是需要对队列的知识有一点了解。</p>
<p>看到大部分题解都使用了pair类型来储存马的坐标</p>
<p>于是打算了解一下其使用方法：</p>
<h2 id="pair">pair</h2>
<p>c++中的结构模板，定义在头文件<utility>中，</p>
<p>提供一个包含2个数据成员的结构体模板，</p>
<p>通过<strong>first，second</strong>访问2个成员。</p>
<h3 id="pair的应用">pair的应用</h3>
<p>pair是将2个数据组合成一个数据，当需要这样的需求时就可以使用pair。</p>
<p>pair类型类似于含两个成员的结构体，</p>
<p>可用于存储<strong>点的坐标</strong>。</p>
<h3 id="pair的构造">pair的构造</h3>
<p>std::pair主要的作用是将两个数据组合成一个数据，</p>
<p>两个数据可以是同一类型或者不同类型。</p>
<p>例如std::pair 或者 std::pair等。pair实质上是一个结构体，其主要的两个成员变量是first和second，这两个变量可以直接使用。</p>
<p>初始化一个pair可以使用构造函数，也可以使用std::make_pair函数，make_pair函数的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span> <span class="built_in">pair</span> <span class="title">make_pair</span><span class="params">(T1 a, T2 b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">pair</span>(a, b); </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>一般make_pair都使用在需要pair做参数的位置，</p>
<p><strong>可以直接调用make_pair生成pair对象。</strong></p>
<p>另一个使用的方面就是pair可以接受隐式的类型转换，这样可以获得更高的灵活度。</p>
<p>但是这样会出现如下问题：例如有如下两个定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">pair</span>(<span class="number">1</span>, <span class="number">1.1</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">1.1</span>);</span><br></pre></td></tr></table></figure>
<p>其中第一个的second变量是float类型，</p>
<p>而make_pair函数会将second变量都转换成double类型。</p>
<h3 id="实例">实例</h3>
<p>下面是一段pair与make_pair的例子程序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"><span class="built_in">pair</span> &lt;<span class="built_in">string</span>,<span class="keyword">double</span>&gt; product1 (<span class="string">&quot;tomatoes&quot;</span>,<span class="number">3.25</span>);</span><br><span class="line"><span class="built_in">pair</span> &lt;<span class="built_in">string</span>,<span class="keyword">double</span>&gt; product2;</span><br><span class="line"><span class="built_in">pair</span> &lt;<span class="built_in">string</span>,<span class="keyword">double</span>&gt; product3; </span><br><span class="line">  </span><br><span class="line">product2.first =<span class="string">&quot;lightbulbs&quot;</span>; 				<span class="comment">// type of first is string</span></span><br><span class="line">product2.second =<span class="number">0.99</span>; 					<span class="comment">// type of second is double </span></span><br><span class="line">product3 = <span class="built_in">make_pair</span> (<span class="string">&quot;shoes&quot;</span>,<span class="number">20.0</span>);</span><br><span class="line">  </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;The price of &quot;</span>&lt;&lt; product1.first &lt;&lt;<span class="string">&quot; is $&quot;</span>&lt;&lt; product1.second &lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;The price of &quot;</span>&lt;&lt; product2.first &lt;&lt;<span class="string">&quot; is $&quot;</span>&lt;&lt; product2.second &lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;The price of &quot;</span>&lt;&lt; product3.first &lt;&lt;<span class="string">&quot; is $&quot;</span>&lt;&lt; product3.second &lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++之路</category>
      </categories>
      <tags>
        <tag>语言功能</tag>
      </tags>
  </entry>
  <entry>
    <title>运算升级：位运算</title>
    <url>/2020/09/05/%E8%BF%90%E7%AE%97%E5%8D%87%E7%BA%A7%EF%BC%9A%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天在刷递归题的时候看到看到两道比较有意思的题</p>
<p><a href="https://www.luogu.com.cn/problem/P1036">P1036 选数</a> 和 <a href="https://www.luogu.com.cn/problem/P1010">P1010 幂次方</a></p>
<p>鉴于我搜索回溯都还没学，数据处理也比较菜，就想到尝试用位运算的方法来解决。</p>
<p>不说废话了来认识一下位运算的一些性质吧。</p>
<h2 id="为什么使用位运算">为什么使用位运算</h2>
<ul>
<li>
<p>数字在计算机中以二进制形式储存，所以使用位运算符计算比使</p>
<p>用算数运算符速度更快</p>
</li>
<li>
<p>对于一类特定的问题，如子集问题，改写数字等，使用二进制&amp;</p>
<p>位运算是十分直观的方法。</p>
</li>
</ul>
<h2 id="位运算的基础运算符">位运算的基础运算符</h2>
<p>先来看一段示例程序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A = <span class="number">85</span>, B = <span class="number">51</span>;</span><br><span class="line"><span class="keyword">int</span> p, q, r, s, u, v;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = A &amp; B;</span><br><span class="line">    q = A | B;</span><br><span class="line">    r = A ^ B;</span><br><span class="line">    s = ~A;</span><br><span class="line">    u = A &lt;&lt; <span class="number">2</span>;</span><br><span class="line">    v = A &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d %d %d&quot;</span>, p, q, r, s, u, v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行得到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">17 119 102 -86 340 10</span><br></pre></td></tr></table></figure>
<h3 id="分析">分析</h3>
<p>首先将A B改写为二进制数</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">6</th>
<th style="text-align:center">5</th>
<th style="text-align:center">4</th>
<th style="text-align:center">3</th>
<th style="text-align:center">2</th>
<th style="text-align:center">1</th>
<th style="text-align:center">0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>&amp;：按位与运算符</p>
<p>与 逻辑运算符&amp;&amp;类似，当参与运算的值均为1时才返回1</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">A</th>
<th style="text-align:center">1</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">A&amp;B</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>|:   按位或运算符</p>
<p>与逻辑运算符  ||  相似，当参与运算的值至少有一个为1就返回1</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">A</th>
<th style="text-align:center">1</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">AorB</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>^ : 按位异或运算符</p>
<p>只有参与运算的值不完全相同才返回1，若均相同（不管同为1还</p>
<p>是0）则输出0.</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">A</th>
<th style="text-align:center">1</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">A^B</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>~ ： 非运算符</p>
<p>输出将输入数据每一位取反</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">A</th>
<th style="text-align:center">1</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">~A</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>&lt;&lt; : 左移运算符</p>
<p>将输入的数据向左（向高位）移位，后面用0补齐</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">8</th>
<th style="text-align:center">7</th>
<th style="text-align:center">6</th>
<th style="text-align:center">5</th>
<th style="text-align:center">4</th>
<th style="text-align:center">3</th>
<th style="text-align:center">2</th>
<th style="text-align:center">1</th>
<th style="text-align:center">0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">A&lt;&lt;2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<p>将两数转换为十进制</p>
<p>A : 85<br>
A&lt;&lt;2 : 340</p>
<p>可以发现将A左移2位相当于乘以2^2</p>
<p>所以得出：A&lt;&lt;n = A * 2^n</p>
<ul>
<li>
<p>: 右移运算符</p>
<p>将输入的数据向右（向低位）移位，前面用0补齐</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">6</th>
<th style="text-align:center">5</th>
<th style="text-align:center">4</th>
<th style="text-align:center">3</th>
<th style="text-align:center">2</th>
<th style="text-align:center">1</th>
<th style="text-align:center">0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">A&gt;&gt;2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p>A = 85</p>
<p>A&gt;&gt;2 = 21</p>
<p>可以发现，与左移相反，右移n位可以将数除以2的n次方</p>
<h2 id="喜闻乐见的例题讲解">喜闻乐见的例题讲解</h2>
<ol>
<li><a href="https://www.luogu.com.cn/problem/P1036">P1036 选数</a></li>
</ol>
<p>这道题其实就是让我们从n个元素中选k个相加，判断和是否为质数</p>
<p>让我们先来看一个简单的例子</p>
<p>假设我们有一个5个元素的数组(下标从1开始）</p>
<table>
<thead>
<tr>
<th style="text-align:center">i</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a[ i ]</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
</tr>
</tbody>
</table>
<p>对于全集 <strong>U={ 1，2 ，3 ，4 ，5 }</strong> ,每个子集都包含其中任意个元素。</p>
<p>有没有什么办法可以给这些不同的子集编号呢？</p>
<p>我们可以以<strong>元素的存在情况</strong>作为依据：</p>
<p>令每个子集的编号为一个5位二进制数，如果其中一位对应的数在子</p>
<p>集中存在，那么那一位为1，否则为0。</p>
<p>以其中一个子集 <strong>S = { 1 , 3 , 5 }</strong> 为例，得到以下表格</p>
<table>
<thead>
<tr>
<th style="text-align:center">a[i]</th>
<th style="text-align:center">5</th>
<th style="text-align:center">4</th>
<th style="text-align:center">3</th>
<th style="text-align:center">2</th>
<th style="text-align:center">1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">U</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<ul>
<li>注意：对于二进制数来说，数位由高到低<strong>递减</strong>。</li>
</ul>
<p>则U的编号为11111，S的编号为10101，</p>
<p>转换成十进制后，U=31，S=21</p>
<p>我们惊喜的发现，<strong>U的大小就等于2^n-1</strong>(其中n为元素个数)</p>
<p>通过这种方法，每一个子集都有一个<strong>唯一</strong>的二进制编号与其一一对应。</p>
<p>接下来该做什么呢？</p>
<p>对于这道题来说，要求其中k个数的和，</p>
<p>就是求<strong>含k个元素的子集每个元素的和</strong>。</p>
<p>而我们编号之后会发现，如果一个子集有k个元素，<br>
那么它的编号中也必有k个‘1’</p>
<p>（如S = { 1 , 3 , 5 }的编号10101中有3个1）</p>
<p>到此为止，这道题的思路就很清晰了，</p>
<p>先计算U的大小，从1到U枚举S，判断S中’1‘的个数</p>
<p>如果等于k，就把S中的元素相加，判断是否为素数，记录答案即可。</p>
<p>AC程序如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;        //*判断质数时需使用sqrt()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;    //*使用__builtin_popcount()需包含该头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">21</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;   <span class="comment">//*判断是否为质数</span></span><br><span class="line">	<span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">2</span>||n==<span class="number">3</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(n);i++)</span><br><span class="line">		<span class="keyword">if</span>(n%i==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cnt_1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;      <span class="comment">//*计算二进制数字中1的个数</span></span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;          <span class="comment">//*也可以用STL中内置的__builtin_popcount()函数代替</span></span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)</span><br><span class="line">            cnt++;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">int</span> U = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;               <span class="comment">//*U为全集，易知 U=2^n-1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> S = <span class="number">1</span>; S &lt;= U;S++)&#123;        <span class="comment">//*枚举每一个子集</span></span><br><span class="line">        <span class="keyword">if</span>(cnt_1(S)==k)&#123;                <span class="comment">//*判断子集中是否有k个元素</span></span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">                <span class="keyword">if</span>(S &amp; (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>)))      <span class="comment">//*判断第i个元素是否在S中</span></span><br><span class="line">                    sum += a[i];</span><br><span class="line">            <span class="keyword">if</span>(is_prime(sum))</span><br><span class="line">                ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.<a href="https://www.luogu.com.cn/problem/P1010">P1010 幂次方</a></p>
<p>这道题其实就是让我们把一个十进制数改写成二的整数次幂之和</p>
<p>所以自然想到采用二进制的做法</p>
<p>我们以题目中的例子进行说明，先将137转换成二进制数观察</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">7</th>
<th style="text-align:center">6</th>
<th style="text-align:center">5</th>
<th style="text-align:center">4</th>
<th style="text-align:center">3</th>
<th style="text-align:center">2</th>
<th style="text-align:center">1</th>
<th style="text-align:center">0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">137</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p>很明显我们可以发现：</p>
<p>需要改写的那一位已经以‘1’的形式存在了</p>
<p>只需要记录数中每一个‘1’在第几位，再对位数递归分解</p>
<p>直到所有的‘1’都在第0~2位上结束。</p>
<p>像这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//todo 位运算部分</span></span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">100</span>];                 <span class="comment">//*储存n的二进制数各位为1的情况</span></span><br><span class="line">    <span class="keyword">int</span> k = n, u=<span class="number">0</span>, i = <span class="number">0</span>;      <span class="comment">//*k暂存n，u作为下标，i记录为第几位</span></span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)</span><br><span class="line">            d[++u] = i;         <span class="comment">//*d[u]=i表示第u个1在第i位</span></span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;                <span class="comment">//*k右移1位</span></span><br><span class="line">        i++;                    <span class="comment">//*位数+1</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>继续来看，我们注意到137的二进制第7位为1，只需要再将7改写为二进制数如下表：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">2</th>
<th style="text-align:center">1</th>
<th style="text-align:center">0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p>此时所有的‘1’都已经在0~2位上，达到了递归的边界，判断输出即可。</p>
<p>附上AC代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rec</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//todo 位运算部分</span></span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">100</span>];                 <span class="comment">//*储存n的二进制数各位为1的情况</span></span><br><span class="line">    <span class="keyword">int</span> k = n, u=<span class="number">0</span>, i = <span class="number">0</span>;      <span class="comment">//*k暂存n，u作为下标，i记录为第几位</span></span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)</span><br><span class="line">            d[++u] = i;         <span class="comment">//*d[u]=i表示第u个1在第i位</span></span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;                <span class="comment">//*k右移1位</span></span><br><span class="line">        i++;                    <span class="comment">//*位数+1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//todo 处理部分</span></span><br><span class="line">    <span class="keyword">while</span>(u)&#123;                   <span class="comment">//*从低到高储存后，从高到低处理</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(d[u]&gt;=<span class="number">3</span>)&#123;                        <span class="comment">//*由于题目要求只能用0，2表示，所以如果这个1在第3或更高位要递归继续分解</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;2(&quot;</span>);                   <span class="comment">//*后面还要递归，先把前面的括号输出</span></span><br><span class="line"></span><br><span class="line">            rec(d[u--]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(u)                           <span class="comment">//*如果u不为零，说明后面还有数，要输出‘+’</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;)+&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span>                            <span class="comment">//*如果u为零，说明已经是最后一个，只输出‘）’</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>&#123;                   <span class="comment">//*如果1在&lt;=2位上</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(d[u]==<span class="number">1</span>&amp;&amp;u!=<span class="number">1</span>)               <span class="comment">//*如果‘1’在第一位上，且不是整个数中的第一个‘1’</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;2+&quot;</span>);               <span class="comment">//*后面还有其它‘1’，要输出‘+’</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(d[u]==<span class="number">1</span>)                <span class="comment">//*如果是第一个‘1’</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;2&quot;</span>);                <span class="comment">//*后面没有其它‘1’了，不输出‘+’</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>((d[u]==<span class="number">0</span>||d[u]==<span class="number">2</span>)&amp;&amp;u!=<span class="number">1</span>)    <span class="comment">//*如果1在第二位或第零位上，且不是整个数中的第一个‘1’</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;2(%d)+&quot;</span>, d[u]);     <span class="comment">//*输出位权和‘+’</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(d[u]==<span class="number">0</span>||d[u]==<span class="number">2</span>)       <span class="comment">//*如果是第一个‘1’</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;2(%d)&quot;</span>, d[u]);      <span class="comment">//*只输出位权</span></span><br><span class="line"></span><br><span class="line">            u--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    rec(n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++之路</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>二进制，位运算</tag>
        <tag>递归</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>about me</title>
    <url>/2020/09/11/about-me/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="a">A</h2>
<h3 id="bb">BB</h3>
]]></content>
  </entry>
  <entry>
    <title>基础算法总结:递归,贪心,搜索</title>
    <url>/2020/10/28/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93-%E9%80%92%E5%BD%92-%E8%B4%AA%E5%BF%83-%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>搜索算法总结</h1>
<p>搜索其实是一种更高效的枚举，这一部分将总结经典的搜索题目，搜索策略，和进行搜索时需要注意的小细节</p>
<h2 id="搜索基本模板">搜索基本模板</h2>
<ul>
<li>DFS</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(当前情况)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(到达枚举终点)&#123;</span><br><span class="line">        记录答案;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(枚举所有可扩展方向)&#123;</span><br><span class="line">        <span class="keyword">if</span>(方向可行)&#123;</span><br><span class="line">            记录现场;</span><br><span class="line">            dfs(扩展的方向);</span><br><span class="line">            清除现场;   <span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>BFS</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(当前情况)</span></span>&#123;</span><br><span class="line">    更新答案，起点入队;</span><br><span class="line">    <span class="keyword">while</span>(队列非空)&#123;</span><br><span class="line">        取出队首,队首出队;</span><br><span class="line">        <span class="keyword">for</span>(枚举所有可扩展方向)&#123;</span><br><span class="line">            <span class="keyword">if</span>(方向可行)&#123;</span><br><span class="line">                记录现场;</span><br><span class="line">                当前方向入队;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="">P1219 八皇后</a></li>
</ul>
<p>八皇后问题是最为经典的搜索问题，在于搜索的策略十分直观清晰。</p>
<p>与迷宫，联通性问题等相似，搜索范围被限定在一个棋盘上，每个可选方向就被抽象为地图上的坐标</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 101</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,ans,a[M];             <span class="comment">//记录第i行棋子的列数</span></span><br><span class="line"><span class="comment">//b1代表列数,b2代表左斜线,b3代表右斜线</span></span><br><span class="line"><span class="keyword">int</span> b1[M], b2[M], b3[M];    <span class="comment">//判断是否在其他棋子的攻击范围内</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;n)&#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">if</span>(ans&lt;=<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++) </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)&#123;    <span class="comment">//按列枚举</span></span><br><span class="line">        <span class="keyword">if</span>( b1[i]==<span class="number">0</span> &amp;&amp; b2[x+i]==<span class="number">0</span> &amp;&amp; b3[x-i+<span class="number">2</span>*n<span class="number">-1</span>]==<span class="number">0</span> )&#123;</span><br><span class="line">            a[x] = i;</span><br><span class="line">            b1[i] = <span class="number">1</span>, b2[x+i] = <span class="number">1</span>, b3[x-i+<span class="number">2</span>*n<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">            dfs(x+<span class="number">1</span>);</span><br><span class="line">            b1[i] = <span class="number">0</span>, b2[x+i] = <span class="number">0</span>, b3[x-i+<span class="number">2</span>*n<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>递归</tag>
        <tag>基础算法</tag>
        <tag>搜索</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>Data Structure</title>
    <url>/2020/11/07/Data-Structure/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><pre><code>“一入DS深似海，从此AC成路人。”
</code></pre>
<p>CSP-S 2020 RP++</p>
<h2 id="ds大家族">DS大家族</h2>
<p>数据结构群像，待填坑… …</p>
<h3 id="线性表">线性表</h3>
<p>栈√ ， 单调栈√</p>
<p>队列√，  单调队列√，  优先队列√，  双端队列√，  循环队列√</p>
<p>链表√，  双向链表√，  循环链表</p>
<p>动态数组</p>
<h3 id="树">树</h3>
<p>二叉树搜索树√，Splay， Treap（树堆）</p>
<p>树状数组，线段树√</p>
<p>Trie（字典树）√，后缀树</p>
<p>堆， 二叉堆√，配对堆… …</p>
<h3 id="集合">集合</h3>
<p>并查集√， 哈希表</p>
<p>set√， multiset√</p>
<h3 id="图">图</h3>
<p>其实图论更多的是算法，后面也会写</p>
<hr>
<p>坑挖好了，开始漫长的填坑之路~~~（bushi</p>
<h2 id="线性表">线性表</h2>
<p><strong>栈</strong></p>
<p>STL中提供了栈的模板，这里总结一下相关的用法</p>
<p><code>#include&lt;stack&gt;</code></p>
<p><code>stack&lt;type&gt; s;</code></p>
<p>支持以下操作：</p>
<ul>
<li><code>s.push()</code></li>
<li><code>s.pop()</code></li>
<li><code>s.top()</code></li>
<li><code>s.empty()</code></li>
<li><code>s.size()</code></li>
</ul>
<p>当然STL很慢，比赛默认编译选项不会开优化</p>
<p>所以下面给出手写栈的方法，已经封装成结构体</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stack</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">105</span>],tot = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        a[++tot] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        tot--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[tot];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tot == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>单调栈</strong></p>
<p>呜，我写的丑</p>
<p><a href="https://www.luogu.com.cn/problem/P5788">P5788 【模板】单调栈</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[maxn], ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    s.push(n), ans[n] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty()&amp;&amp;a[i]&gt;=a[s.top()])</span><br><span class="line">            s.pop();</span><br><span class="line">        ans[i] = s.empty() ? <span class="number">0</span> : s.top();</span><br><span class="line">        s.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，单调栈也可以用于离线解决 RMQ 问题。</p>
<p><strong>队列</strong></p>
<p>STL中需要  <code>#include&lt;queue&gt;</code></p>
<p>同样给出封装后的结构体</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">queue</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">1005</span>];</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">1</span>, tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        a[++tail] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        head++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">front</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[head];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tail - head + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head&gt;tail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>双端队列</strong></p>
<p>STL太香啦</p>
<p><code>#include&lt;deque&gt;</code></p>
<p><code>deque&lt;int&gt; q;</code></p>
<p>支持的操作：</p>
<ul>
<li>
<p><code>q[i]</code>:返回队列中下标为i的元素的引用。</p>
</li>
<li>
<p><code>q.front()</code>: 返回的一个元素的引用。</p>
</li>
<li>
<p><code>q.back()</code> : 返回最后一个元素的引用。</p>
</li>
<li>
<p><code>q.pop_back()</code>: 删除尾部的元素，不返回值。</p>
</li>
<li>
<p><code>q.pop_front()</code>: 删除头部元素，不返回值。</p>
</li>
<li>
<p><code>q.push_back(e)</code>: 在队尾添加一个元素e。</p>
</li>
<li>
<p><code>q.push_front(e)</code>: 在对头添加一个元素e。</p>
</li>
</ul>
<p><strong>单调队列</strong></p>
<p>单调队列中所说的“队列”和常规的队列含义不同，</p>
<p>其队首和队尾都支持插入删除操作</p>
<p>本质上是由双端队列实现的，</p>
<p>相当于使用<strong>双端队列维护单调序列</strong></p>
<p>把模板题放在这里：</p>
<p><a href="https://www.luogu.com.cn/problem/P1886">P1886 滑动窗口 /【模板】单调队列</a></p>
<p>核心代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Max</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()&amp;&amp;a[i].val&gt;=q.back().val)</span><br><span class="line">            q.pop_back();</span><br><span class="line">        q.push_back(a[i]);</span><br><span class="line">        <span class="keyword">while</span>(q.front().num&lt;=i-k)</span><br><span class="line">            q.pop_front();</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=k)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q.front().val);</span><br><span class="line">    &#125;</span><br><span class="line">    q.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>循环队列</strong></p>
<p>其实很简单</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    q.push(q.front());</span><br><span class="line">    q.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就开始转圈圈了~~~</p>
<p><strong>优先队列</strong></p>
<p>STL中提供了<code>std::priority_queue</code></p>
<p>实际上是采用二叉堆来实现的</p>
<p>定义方式：<br>
<code>priority_queue&lt;Type, Container, Functional&gt;</code></p>
<ul>
<li>
<p><code>type</code>是数据类型，可以是<code>int</code>，<code>float</code>等或自己写的结构体类型</p>
</li>
<li>
<p><code>Container</code>是容器，只能是<code>vector</code>或<code>deque</code>，默认<code>vector</code></p>
</li>
<li>
<p><code>Functional</code>是优先度判断方式，包括<code>less&lt;int&gt;</code>（递减）和</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">定义递减的int型优先队列：&#96;&#96;&#96;priority_queue&lt;int&gt; q;&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">常用操作：</span><br><span class="line"></span><br><span class="line">- q.empty()      如果队列为空，则返回真</span><br><span class="line"></span><br><span class="line">- q.pop() 		删除对顶元素，删除第一个元素</span><br><span class="line"></span><br><span class="line">- q.push()		加入一个元素</span><br><span class="line"></span><br><span class="line">- q.size()		返回优先队列中拥有的元素个数</span><br><span class="line"></span><br><span class="line">- q.top()		返回优先队列队首元素（有最高优先级的元素）</span><br><span class="line"></span><br><span class="line">因为来不及仔细写堆了就只能靠STL救命了，~~其实堆的代码也很简单~~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**链表**</span><br><span class="line"></span><br><span class="line">因为单向链表太废了，所以就不写了</span><br><span class="line"></span><br><span class="line">直接给一个双向链表（~~其实并没有什么区别~~</span><br><span class="line"></span><br><span class="line">另外：STL里面的链表更废（std::list</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;cpp</span><br><span class="line">struct node&#123;</span><br><span class="line">    int pre, nxt;       &#x2F;&#x2F;*记录前驱和后继</span><br><span class="line">    int key;            &#x2F;&#x2F;*记录节点的值</span><br><span class="line">    node(int _key &#x3D; 0,int _pre &#x3D; 0,int _nxt &#x3D; 0)&#123;</span><br><span class="line">        pre &#x3D; _pre;</span><br><span class="line">        nxt &#x3D; _nxt;</span><br><span class="line">        key &#x3D; _key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">node s[1005];       &#x2F;&#x2F;*结点池</span><br><span class="line"></span><br><span class="line">int tot &#x3D; 0;        &#x2F;&#x2F;*记录已经使用了几个位置</span><br><span class="line"></span><br><span class="line">int find(int x)&#123;    &#x2F;&#x2F;*查找x的节点编号，遍历链表</span><br><span class="line">    int now &#x3D; 1;</span><br><span class="line">    while(now&amp;&amp;s[now].key!&#x3D;x)</span><br><span class="line">        now &#x3D; s[now].nxt;</span><br><span class="line">    return now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ins_front(int x,int y)&#123;</span><br><span class="line">    int now &#x3D; find(x);</span><br><span class="line">    s[++tot] &#x3D; node(y, s[now].pre, now);</span><br><span class="line">    s[s[now].pre].nxt &#x3D; tot;</span><br><span class="line">    s[now].pre &#x3D; tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ins_back(int x,int y)&#123; &#x2F;&#x2F;*把y插在x后面</span><br><span class="line">    int now &#x3D; find(x);      &#x2F;&#x2F;*现在s[now].key &#x3D; x</span><br><span class="line">    s[++tot] &#x3D; node(y, now, s[now].nxt);</span><br><span class="line">    &#x2F;&#x2F;*y的前驱为now，后继为s[now].nxt</span><br><span class="line">    s[s[now].nxt].pre &#x3D; tot;</span><br><span class="line">    &#x2F;&#x2F;*更新原先now的后继的pre</span><br><span class="line">    s[now].nxt &#x3D; tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int ask_front(int x)&#123;</span><br><span class="line">    int now &#x3D; find(x);</span><br><span class="line">    return s[s[now].pre].key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int ask_back(int x)&#123;</span><br><span class="line">    int now &#x3D; find(x);</span><br><span class="line">    return s[s[now].nxt].key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void del(int x)&#123;</span><br><span class="line">    int now &#x3D; find(x);</span><br><span class="line">    int lf &#x3D; s[now].pre, rt &#x3D; s[now].nxt;</span><br><span class="line">    s[lf].nxt &#x3D; rt;</span><br><span class="line">    s[rt].pre &#x3D; lf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="树">树</h2>
<p><strong>二叉查找树（BST）</strong></p>
<p>码量还是有点大的~~~</p>
<p>所以只放一个BST的结构体</p>
<p><a href="https://www.luogu.com.cn/problem/P5076">P5076 【深基16.例7】普通二叉树（简化版）</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> left, right;</span><br><span class="line">    <span class="keyword">int</span> size, value, num;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> l=<span class="number">0</span>,<span class="keyword">int</span> r=<span class="number">0</span>,<span class="keyword">int</span> s=<span class="number">0</span>,<span class="keyword">int</span> v=<span class="number">0</span>)&#123;</span><br><span class="line">        left = l, right = r, size = s, value = v;</span><br><span class="line">        num = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; t[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    t[root].size = t[t[root].left].size + t[t[root].right].size + t[root].num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rank</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;t[root].value)</span><br><span class="line">            <span class="keyword">return</span> rank(x, t[root].left);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;t[root].value)</span><br><span class="line">            <span class="keyword">return</span> rank(x, t[root].right) + t[t[root].left].size + t[root].num;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> t[t[root].left].size + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -INF;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=t[t[root].left].size)</span><br><span class="line">        <span class="keyword">return</span> kth(x, t[root].left);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x&lt;=t[t[root].left].size+t[root].num)</span><br><span class="line">        <span class="keyword">return</span> t[root].value;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> kth(x - t[t[root].left].size - t[root].num, t[root].right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> &amp;root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;t[root].value)</span><br><span class="line">        <span class="keyword">if</span>(!t[root].left)</span><br><span class="line">            t[t[root].left = ++cnt] = Node(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            insert(x, t[root].left);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x==t[root].value)</span><br><span class="line">        t[root].num++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span>(!t[root].right)</span><br><span class="line">            t[t[root].right = ++cnt] = Node(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            insert(x, t[root].right);</span><br><span class="line">    update(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>线段树</strong></p>
<p>萌萌的数据结构肯定少不了线段树</p>
<p>数组储存记得四倍空间哦~</p>
<p><a href="https://www.luogu.com.cn/problem/P3372">P3372 【模板】线段树 1</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>  maxn = <span class="number">100010</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">LL n, m, op;</span><br><span class="line">LL a[maxn], d[maxn&lt;&lt;<span class="number">2</span>], b[maxn&lt;&lt;<span class="number">2</span>];		<span class="comment">//四倍空间</span></span><br><span class="line">LL ans[maxn],k;</span><br><span class="line"></span><br><span class="line"><span class="comment">//?建树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(LL s, LL t, LL p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//todo 对 [s,t] 区间建立线段树,当前根的编号为 p</span></span><br><span class="line">    <span class="comment">//*递归建树，边界条件为区间长度为1，此时 d[i]=a[s]=a[t]</span></span><br><span class="line">    <span class="keyword">if</span>(s==t)&#123;</span><br><span class="line">        d[p] = a[s];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL m = (s + t) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//todo 递归对左右区间建树</span></span><br><span class="line">    <span class="comment">//*左儿子序号为p*2，右儿子序号为p*2+1</span></span><br><span class="line">    build(s, m, p &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    build(m + <span class="number">1</span>, t, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//*根节点大小为左右儿子节点之和</span></span><br><span class="line">    d[p] = d[p &lt;&lt; <span class="number">1</span>] + d[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//?区间查询</span></span><br><span class="line"><span class="function">LL <span class="title">getsum</span><span class="params">(LL l, LL r, LL s, LL t, LL p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//*[l,r] 为查询区间,[s,t] 为当前节点包含的区间,p 为当前节点的编号</span></span><br><span class="line">    <span class="keyword">if</span>(s&gt;=l&amp;&amp;t&lt;=r)</span><br><span class="line">        <span class="keyword">return</span> d[p];</span><br><span class="line">    <span class="comment">//*当前区间为询问区间的子集时直接返回当前区间的和</span></span><br><span class="line">    </span><br><span class="line">    LL m = (s + t) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    LL sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//*如果当前节点的懒标记非空,则更新当前节点两个子节点的值和懒标记值</span></span><br><span class="line">    <span class="keyword">if</span> (b[p]) &#123;</span><br><span class="line">        d[p &lt;&lt; <span class="number">1</span>] += b[p] * (m - s + <span class="number">1</span>);</span><br><span class="line">        d[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += b[p] * (t - m);</span><br><span class="line">        b[p &lt;&lt; <span class="number">1</span>] += b[p];            <span class="comment">//*将标记下传给子节点</span></span><br><span class="line">        b[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += b[p];                       </span><br><span class="line">        b[p] = <span class="number">0</span>;                    <span class="comment">//*清空当前节点的标记</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//*如果左儿子代表的区间 [l,m] 与询问区间有交集,则递归查询左儿子</span></span><br><span class="line">    <span class="keyword">if</span>(l&lt;=m)</span><br><span class="line">        sum += getsum(l, r, s, m, p &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//*如果右儿子代表的区间 [m+1,r] 与询问区间有交集,则递归查询右儿子</span></span><br><span class="line">    <span class="keyword">if</span>(r&gt;m)</span><br><span class="line">        sum += getsum(l, r, m + <span class="number">1</span>, t, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//?区间修改(增加)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(LL l, LL r, LL c, LL s, LL t, LL p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//*[l,r] 为修改区间,c 为被修改的元素的变化量,</span></span><br><span class="line">    <span class="comment">//*[s,t] 为当前节点包含的区间,p为当前节点的编号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//*当前区间为修改区间的子集时直接修改当前节点的值,然后打标记,结束修改</span></span><br><span class="line">    <span class="keyword">if</span>(s&gt;=l&amp;&amp;t&lt;=r)&#123;</span><br><span class="line">        d[p] += (t - s + <span class="number">1</span>) * c;</span><br><span class="line">        b[p] += c;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LL m = (s + t) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//*如果当前节点的懒标记非空,则更新当前节点两个子节点的值和懒标记值</span></span><br><span class="line">    <span class="keyword">if</span>(b[p]&amp;&amp;s!=t)&#123;</span><br><span class="line">        d[p &lt;&lt; <span class="number">1</span>] += (m - s + <span class="number">1</span>) * b[p];</span><br><span class="line">        d[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += (t - m) * b[p];</span><br><span class="line">        <span class="comment">//*将标记下传给子节点</span></span><br><span class="line">        b[p &lt;&lt; <span class="number">1</span>] += b[p];</span><br><span class="line">        b[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += b[p];</span><br><span class="line">        <span class="comment">//*清空当前节点的标记</span></span><br><span class="line">        b[p] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=m)</span><br><span class="line">        update(l, r, c, s, m, p &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(m&lt;r)</span><br><span class="line">        update(l, r, c, m + <span class="number">1</span>, t, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">    d[p] = d[p &lt;&lt; <span class="number">1</span>] + d[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ST表</strong></p>
<p>ST表对于RMQ等<strong>可重复贡献问题</strong>有十分优秀的表现</p>
<p>常数小于线段树，但只支持查询操作，不支持修改，删除。</p>
<p>ST表的实现采用了倍增的思想。</p>
<p><a href="https://www.luogu.com.cn/problem/P3865">P3865 【模板】ST表</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> f[maxn][<span class="number">22</span>], log2[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))&#123;</span><br><span class="line">        <span class="keyword">if</span> (ch==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            f = <span class="number">-1</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))&#123;</span><br><span class="line">        x = x * <span class="number">10</span> + ch - <span class="number">48</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    log2[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        log2[i] = log2[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">21</span>;j++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n;i++)</span><br><span class="line">            f[i][j] = max(f[i][j - <span class="number">1</span>], f[i + (<span class="number">1</span> &lt;&lt; (j<span class="number">-1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = log2[r - l + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> max(f[l][k], f[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), m = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        f[i][<span class="number">0</span>] = read();</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> l = read(), r = read();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, query(l, r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Trie</strong></p>
<p><a href="https://www.luogu.com.cn/problem/P2580">P2580 于是他错误的点名开始了</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxa = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trie</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> node[maxn][maxa], cnt;</span><br><span class="line">    <span class="keyword">int</span> exist[maxn];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; s[i];i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> c = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(!node[p][c])</span><br><span class="line">                node[p][c] = ++cnt;</span><br><span class="line">            p = node[p][c];</span><br><span class="line">        &#125;</span><br><span class="line">        exist[p] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; s[i];i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> c = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(!node[p][c])</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            p = node[p][c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> exist[p]++;		<span class="comment">//不需要计数的话可以改成bool型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; trie;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> s[<span class="number">52</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">        trie.insert(s + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> s[<span class="number">52</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> rslt = trie.find(s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(rslt==<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;OK\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rslt&gt;<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;REPEAT\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;WRONG\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="集合">集合</h2>
<p><strong>并查集</strong></p>
<p><a href="https://www.luogu.com.cn/problem/P1551">P1551 亲戚</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5050</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">set</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> fa[maxn];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==fa[x])</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">return</span> fa[x] = find(fa[x]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f1 = find(a);</span><br><span class="line">        <span class="keyword">int</span> f2 = find(b);</span><br><span class="line">        <span class="keyword">if</span>(f1!=f2)</span><br><span class="line">            fa[f1] = f2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">set</span> s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, p;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        s.fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        s.join(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span>(s.find(x)==s.find(y))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>std::map</strong></p>
<p>map是使用红黑树实现的映射表</p>
<p>头文件：<code>#include&lt;map&gt;</code></p>
<p>定义方法：<code>map&lt;type_key,type_data&gt; m;</code></p>
<ul>
<li>
<p><code>m[key]</code>:	可以访问下标为“key”的元素</p>
</li>
<li>
<p><code>m.end()</code>: 返回映射表中最后元素的<strong>下一个元素</strong>的地址</p>
</li>
<li>
<p><code>m.find()</code>: 查找，返回地址，不存在则返回<code>m.end()</code></p>
</li>
<li>
<p><code>m.empty()</code></p>
</li>
<li>
<p><code>m.size()</code></p>
</li>
</ul>
<p>例题：<a href="https://www.luogu.com.cn/problem/P5266">P5266 【深基17.例6】学籍管理</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">int</span> n, opt, score, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;opt;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;name&gt;&gt;score;</span><br><span class="line">            <span class="keyword">if</span>(!m[name])</span><br><span class="line">                ans++;</span><br><span class="line">            m[name] = score;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;OK&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;name;</span><br><span class="line">            <span class="keyword">if</span>(m[name])</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;m[name]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Not found&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;name;</span><br><span class="line">            <span class="keyword">if</span>(m[name])&#123;</span><br><span class="line">                m[name] = <span class="number">0</span>;</span><br><span class="line">                ans--;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Deleted successfully&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Not found&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>std::set</strong></p>
]]></content>
  </entry>
</search>
